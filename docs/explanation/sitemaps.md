# Sitemaps in WordPress: A Comprehensive Overview

## What is a Sitemap?
A sitemap is an XML file that provides a structured list of pages on a website by helping search engines discover and crawl content more efficiently. It acts as a roadmap of your website's structure, containing important metadata about each page.

Since WordPress 5.5, there's a built-in XML sitemap generator that:

* Automatically creates sitemaps for posts, pages, and custom post types
* Dynamically updates as content is added, modified, or deleted
* Provides basic SEO and indexing support out of the box

However, this default sitemap lacks customization options, which is why many users opt for plugins like Yoast SEO or Jetpack to generate more comprehensive sitemaps.

You can view the current sitemap generated by WordPress by visiting **yourdomain.com/sitemap.xml** in your browser.

![Image showing sitemap for a specific website](./sitemaps-1.png)

## Sitemaps in Headless WordPress
Headless WordPress environments introduce unique challenges for sitemap generation:

* **Separation of content management and frontend rendering**: In traditional WordPress setups, content management and frontend rendering are integrated. However, in headless environments, WordPress acts as a backend CMS, while the frontend is handled by frameworks like Next.js. This separation requires custom solutions for sitemap generation.

* **Dynamic routes**: Dynamic routes in frameworks like Next.js may not be directly accessible or easily discoverable by search engines.

* **Need for custom sitemap generation and management**: Due to the decoupling of backend and frontend, traditional WordPress sitemap plugins might not work seamlessly. Therefore, custom approaches are needed to generate and manage sitemaps effectively.

To address those, there are some proposed solutions for headless sitemap implementation:

1. **Headless WordPress-Based sitemap generation**

Approach: You create a custom GraphQL field in WordPress that generates the sitemap XML. This can be achieved by using a plugin like WP-GraphQL or by extending it with custom code.

Example Code:

```php
add_action('graphql_register_types', function () {
    register_graphql_field('RootQuery', 'sitemapXml', [
        'type' => 'String',
        'description' => 'Sitemap XML as a string',
        'args' => [
            'baseUrl' => [
                'type' => 'String',
                'required' => true,
            ],
        ],
        'resolve' => function ($root, $args) {
            $sitemapXml = generateSitemapXml($args['baseUrl']);
            return $sitemapXml;
        },
    ]);
});
function generateSitemapXml($baseUrl) {
    $posts = get_posts([
        'post_type' => ['post', 'page', 'custom_type'],
        'numberposts' => -1
    ]);

    $sitemap_xml = '<?xml version="1.0" encoding="UTF-8"?>';
    $sitemap_xml .= '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">';

    foreach ($posts as $post) {
        $sitemapXml .= '<url>';
        $sitemapXml .= '<loc>' . $baseUrl . '/' . $post->post_name . '</loc>';
        $sitemapXml .= '<lastmod>' . get_the_modified_date('Y-m-d', $post) . '</lastmod>';
        $sitemapXml .= '</url>';
    }

    $sitemap_xml .= '</urlset>';

    // Expose via API or static file generation
    return $sitemap_xml;
}
```
Now, you can query this custom field in your GraphQL query to fetch the sitemap XML as a string.

```graphql
query GetSitemapXml($baseUrl: String!) {
  sitemapXml(baseUrl: $baseUrl)
}
```
This query will return the sitemap XML as a string, which you can then use in your Next.js application to generate the sitemap dynamically.

- **Pros**
    * Headless compatibility: Generates sitemaps with frontend URLs.
    * Flexibility and customization: Customizable queries for specific data needs.

- **Cons**
    * Complex setup: Requires GraphQL knowledge and setup.
    * Pagination Limitations: Default limits require custom pagination handling.
    * Plugin Compatibility Issues: Potential issues with traditional WordPress plugins.


2. **Server side rendering sitemap implementation**

Approach: Use server API calls to dynamically generate a sitemap based on fetched WordPress content. Implement server-side rendering to ensure the sitemap is always up-to-date.

Example code in Next.js pages router:

```javascript
import { getAllPosts } from '../lib/api';

export default function Sitemap() {}

export async function getServerSideProps({ res }) {
    const posts = await getAllPosts();
    const sitemap = generateSitemap(posts);

    res.setHeader('Content-Type', 'text/xml');
    res.write(sitemap);
    res.end();

    return { props: {} };
}

function generateSitemap(posts) {
    return `<?xml version="1.0" encoding="UTF-8"?>
    <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
        ${posts.map(post => `
            <url>
                <loc>${process.env.FRONTEND_SITE_URL}/${post.slug}</loc>
                <lastmod>${post.modifiedDate}</lastmod>
            </url>
        `).join('')}
    </urlset>`;
}
```
- **Pros**
    * Dynamic and always up-to-date: SSR ensures that the sitemap is dynamically generated and always reflects the latest content changes.

- **Cons**: 
    * Increased complexity: Implementing SSR requires additional setup and can increase the complexity of your application, especially for complex sites.
    * Potential performance issues: Frequent server requests can lead to slower page rendering if not optimized properly

3. **Static sitemap generation**

Approach: This approach involves creating the sitemap during the build process of the application and storing it as a static file in the public directory. This approach offers excellent performance since it eliminates runtime overhead, but it requires a rebuild whenever content is updated.

- **Pros**
    * Performance: Since the sitemap is pre-generated and stored as a static file, it can be served quickly without any additional processing.
    * No Runtime overhead: There are no server-side computations needed to generate the sitemap on each request.

- **Cons**
    * Requires rebuild for content updates: Any changes to content require a full rebuild of the site to update the sitemap, which can be time-consuming for large sites.
    * Inclusion/Exclusion rules: Plugins like Yoast SEO or All in One SEO allow you to include or exclude specific post types, taxonomies, or custom fields from the sitemap. If your custom sitemap generation doesn't account for these settings, it might include unnecessary content or miss important pages.